package org.rampart.lang.java.parser;

import org.rampart.lang.api.*;
import org.rampart.lang.api.core.RampartApp;
import org.rampart.lang.api.core.RampartRule;
import org.rampart.lang.grammar.RampartBaseVisitor;
import org.rampart.lang.grammar.RampartParser;
import org.rampart.lang.api.constants.RampartGeneralConstants;
import org.rampart.lang.impl.core.InvalidRampartRuleException;
import org.rampart.lang.impl.core.Validatable;
import org.rampart.lang.impl.factory.RampartAppValidatorFactory;
import org.rampart.lang.impl.factory.RampartRuleValidatorFactory;
import org.rampart.lang.java.InvalidRampartAppException;
import org.rampart.lang.java.builder.RampartAppBuilder;
import org.rampart.lang.java.builder.RampartRuleBuilder;

import java.util.*;

import static org.rampart.lang.java.RampartPrimitives.*;

/**
 * Class to visit each of the nodes in the AST generated by the  RampartParser.
 */
public class RampartSingleAppVisitor extends RampartBaseVisitor<RampartApp> {

    private RampartSymbolTable<String, RampartList> symbolTable;

    public RampartSingleAppVisitor() {
    }

    @Override
    public RampartApp visitApp(RampartParser.AppContext ctx) {
        RampartAppBuilder rampartAppBuilder = createRampartAppBuilder(ctx);

        List<RampartRule> rules = new ArrayList<RampartRule>();
        for (RampartParser.RuleDeclarationContext ruleDeclarationContext : ctx.ruleDeclaration()) {
            visitRampartRuleDeclaration(ruleDeclarationContext);
            Validatable<? extends RampartRuleBuilder, InvalidRampartRuleException> validatable =
                    RampartRuleValidatorFactory.createRuleValidator(
                            rampartAppBuilder.getRequiredLanguageVersion(),
                            symbolTable);
            if (validatable == null) {
                continue;
            }
            try {
                RampartRule rule = validatable.validate().createRampartRule(rampartAppBuilder.getAppName());
                if (containsRuleWithSameName(rules, rule.getRuleName())) {
                    throw new InvalidRampartRuleException(
                            "duplicate rule name within the same app. Offending rule name \"" + rule.getRuleName() + "\"");
                }
                rules.add(rule);
            } catch (InvalidRampartRuleException iare) {
                throw new InvalidRampartAppException(iare.getMessage(), iare);
            }
        }

        if (rules.isEmpty()) {
            throw new InvalidRampartAppException("app \"" + rampartAppBuilder.getAppName() + "\" does not contain any valid rules");
        }
        rampartAppBuilder.addRules(rules.toArray(new RampartRule[rules.size()]));
        return rampartAppBuilder.createRampartObject();
    }

    private RampartList visitRampartParameterListDeclaration(
             RampartParser.ParameterListDeclarationContext ctx) {
        return visitRampartParameterList(ctx.parameterList());
    }

    private RampartList visitRampartParameterList(RampartParser.ParameterListContext ctx) {
        if (ctx == null) {
            return newRampartList();
        }
        List<RampartObject> params = new ArrayList<RampartObject>();
        for (RampartParser.ParameterContext parameterContext : ctx.parameter()) {
            params.add(visitRampartParameter(parameterContext));
        }
        return newRampartList(params.toArray(new RampartObject[0]));
    }

    private RampartObject visitRampartParameter(RampartParser.ParameterContext ctx) {
        if (ctx == null) {
            return null;
        } else if (ctx.dictionary() != null) {
            return visitRampartDictionary(ctx.dictionary());
        } else if (ctx.dictionaryNVP() != null) {
            return visitRampartDictionaryNVP(ctx.dictionaryNVP());
        } else if (ctx.list() != null) {
            return visitRampartList(ctx.list());
        }
        return visitRampartValue(ctx.value());
    }

    private RampartObject visitRampartValue(RampartParser.ValueContext ctx) {
        if (ctx != null) {
            if (ctx.constant() != null) {
                return newRampartConstant(ctx.constant().getText());
            } else if (ctx.FLOAT() != null) {
                return newRampartFloat(Float.parseFloat(ctx.FLOAT().toString()));
            } else if (ctx.INTEGER() != null) {
                return newRampartInteger(Integer.parseInt(ctx.INTEGER().toString()));
            } else if (ctx.QUOTED_STRING() != null) {
                // Two characters are special and have to be escaped:
                // " - because it is the character that normally ends the String in RAMPART
                // \ - because it is the escape character.
                // The below logic does it:
                String quotedString = ctx.QUOTED_STRING().toString();
                return newRampartString(
                        // Need to strip double quotes that are parsed by ANTLR along with the string content
                        quotedString.substring(1, quotedString.length() - 1)
                        // Need to replace all escaped double-quote with the actual double-quote. (ANTLR does not do it.)
                        .replace("\\\"", "\"")
                        // Need to replace all escaped backslashes with the single backslash.
                        .replace("\\\\", "\\")
                        // Finally, just a note. We are NOT replacing backslashes that were not consumed by the above
                        // replacements. That is we are not replacing standalone backslashes.
                        // Yes, the strict syntax would demand that they were escaped, but there is no harm
                        // in allowing them.
                        //
                        // The only consequence of this is that RAMPART programmer has now two ways of writing
                        // backslash inside the RAMPART String: " \ " and " \\ ", after parsing both are in memory as " \ ".
                        // And when in RampartString we are formatting the in memory String to RAMPART string both will be printed
                        // as " \\ ".
                );
            } else if (ctx.BOOLEAN() != null) {
                if (RampartBoolean.TRUE.toString().equals(ctx.BOOLEAN().toString())) {
                    return RampartBoolean.TRUE;
                } else if (RampartBoolean.FALSE.toString().equals(ctx.BOOLEAN().toString())) {
                    return RampartBoolean.FALSE;
                }
            }
        }
        return null;
    }

    private Map<String, RampartList> visitRampartAppDeclaration(List< RampartParser.AppDeclarationContext> contexts) {
        if (contexts.isEmpty()) {
            return Collections.EMPTY_MAP;
        }
        HashMap<String, RampartList> appDeclarations = new HashMap<String, RampartList>();
        for (RampartParser.AppDeclarationContext ctx : contexts) {
            appDeclarations.put(
                    ctx.IDENTIFIER().getText(),
                    visitRampartParameterListDeclaration(ctx.parameterListDeclaration()));
        }
        return appDeclarations;
    }

    private void visitRampartRuleDeclaration(RampartParser.RuleDeclarationContext ctx) {
        // To keep insertion order
        symbolTable = new RampartSymbolTable<String, RampartList>();
        symbolTable.put(ctx.startName.getText(),
                visitRampartParameterListDeclaration(ctx.parameterListDeclaration()));

        for (RampartParser.NestedRuleDeclarationContext nestedRuleDeclarationContext : ctx
                .nestedRuleDeclaration()) {
            visitRampartNestedRuleDeclaration(nestedRuleDeclarationContext);
        }
        if (ctx.sourceCodeDeclaration() != null) {
            visitRampartSourceCodeDeclaration(ctx.sourceCodeDeclaration());
        }
    }

    private void visitRampartNestedRuleDeclaration(RampartParser.NestedRuleDeclarationContext ctx) {
        // This handles the entry|exit () case
        if (ctx.parameterListDeclaration().parameterList() == null) {
            symbolTable.put(ctx.IDENTIFIER().getText(), RampartList.EMPTY);
            return;
        }

        symbolTable.put(ctx.IDENTIFIER().getText(),
                visitRampartParameterListDeclaration(ctx.parameterListDeclaration()));
    }

    private RampartObject visitRampartExpression(RampartParser.ExpressionContext ctx) {
        if (ctx == null) {
            return null;
        }
        if (ctx.dictionary() != null) {
            return visitRampartDictionary(ctx.dictionary());
        } else if (ctx.list() != null) {
            return visitRampartList(ctx.list());
        }
        return visitRampartValue(ctx.value());
    }

    private RampartList visitRampartList(RampartParser.ListContext ctx) {
        return visitRampartExpressionList(ctx.expressionList());
    }

    private RampartList visitRampartExpressionList(RampartParser.ExpressionListContext ctx) {
        if (ctx == null) {
            return RampartList.EMPTY;
        }
        List<RampartObject> expressions = new ArrayList<RampartObject>();
        for (RampartParser.ExpressionContext expressionContext : ctx.expression()) {
            expressions.add(visitRampartExpression(expressionContext));
        }
        return newRampartList(expressions.toArray(new RampartObject[0]));
    }

    private RampartNamedValue visitRampartDictionaryNVP(RampartParser.DictionaryNVPContext ctx) {
        return newRampartNamedValue(visitRampartNvpName(ctx.nvpName()), visitRampartNvpValue(ctx.nvpValue()));
    }

    private RampartConstant visitRampartNvpName(RampartParser.NvpNameContext ctx) {
        return newRampartConstant(ctx.IDENTIFIER().getText());
    }

    private RampartObject visitRampartNvpValue(RampartParser.NvpValueContext ctx) {
        return visitRampartExpression(ctx.expression());
    }

    private RampartList visitRampartDictionary(RampartParser.DictionaryContext ctx) {
        return visitRampartDictionaryNVPList(ctx.dictionaryNVPList());
    }

    private RampartList visitRampartDictionaryNVPList(RampartParser.DictionaryNVPListContext ctx) {
        List<RampartNamedValue> nvps = new ArrayList<RampartNamedValue>();
        for (RampartParser.DictionaryNVPContext dictionaryNVPContext : ctx.dictionaryNVP()) {
            nvps.add(visitRampartDictionaryNVP(dictionaryNVPContext));
        }
        return newRampartList(nvps.toArray(new RampartNamedValue[0]));
    }

    private void visitRampartSourceCodeDeclaration(RampartParser.SourceCodeDeclarationContext ctx) {
        symbolTable.put(ctx.CODE().getText(),
                visitRampartParameterListDeclaration(ctx.parameterListDeclaration()));
        symbolTable.put(RampartGeneralConstants.SOURCE_CODE_KEY.toString(),
                newRampartList(visitRampartSourceCode(ctx.sourceCode())));
    }

    private RampartString visitRampartSourceCode(RampartParser.SourceCodeContext ctx) {
        return newRampartString(ctx.getText());
    }

    /**
     * Returns 1st value in the symbol table keyset. By the order of visitation we enforce
     * this will be the name of the rule. eg. "patch" or "filesystem"
     * @param symbolTable symbol table with content collected from the AST.
     * @return name of the rule currently being visited
     */
    public static RampartConstant getRampartRuleName(Map<String, RampartList> symbolTable) {
        return newRampartConstant(symbolTable.keySet().iterator().next().toLowerCase());
    }

    private static boolean containsRuleWithSameName(List<RampartRule> rulesList, RampartString ruleName) {
        for (RampartRule rule: rulesList) {
            if (rule.getRuleName().equals(ruleName)) {
                return true;
            }
        }
        return false;
    }

    private RampartAppBuilder createRampartAppBuilder(RampartParser.AppContext ctx) throws InvalidRampartAppException {
        RampartList appValueList = visitRampartParameterListDeclaration(ctx.parameterListDeclaration());
        Map<String, RampartList> appDeclarations = visitRampartAppDeclaration(ctx.appDeclaration());
        return RampartAppValidatorFactory.createAppValidator(appValueList, appDeclarations).validate();
    }
}
